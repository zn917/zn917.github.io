{"meta":{"title":"柊南","subtitle":null,"description":null,"author":"柊南","url":"http://zn917.github.io","root":"/"},"pages":[],"posts":[{"title":"MySQL基于InnoDB的乐观锁、悲观锁理解","slug":"MySQL基于InnoDB的乐观锁、悲观锁理解","date":"2019-07-29T07:02:55.000Z","updated":"2019-07-29T07:04:47.528Z","comments":true,"path":"2019/07/29/MySQL基于InnoDB的乐观锁、悲观锁理解/","link":"","permalink":"http://zn917.github.io/2019/07/29/MySQL基于InnoDB的乐观锁、悲观锁理解/","excerpt":"","text":"MySQL基于InnoDB的乐观锁、悲观锁理解查看存储引擎1show engines; 乐观锁每次获取数据的时候，都不担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断数据是否被别人修改了，如果数据被其他线程修改不进行数据更新，没有被其他线程修改则进行数据更新，由于数据没有进行加锁，此期间数据可以被其他线程进行读写操作 使用场景比较适合读取操作频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量 使用方法使用数据版本（Version）记录机制实现，就是给数据增加一个版本标识，一般通过数据库表增加一个“version”字段来实现，读取数据时，将version字段的值一同读出，数据每更新一次，version值+1，提交更新时，判断数据库对应记录的当前版本信息与第一次取出来的version进行对比，版本号相等就更新，否则认为是过期数据 123update TABLEset value=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;;","categories":[],"tags":[]},{"title":"my first blog","slug":"我的第一篇","date":"2019-07-22T05:08:55.000Z","updated":"2019-07-22T10:07:12.079Z","comments":true,"path":"2019/07/22/我的第一篇/","link":"","permalink":"http://zn917.github.io/2019/07/22/我的第一篇/","excerpt":"","text":"我的第一篇博客其实很早之前就有做一个个人博客的念头了，一方面对于求职来说，无论是校招还是社招，拥有属于自己的个人博客无疑是个加分项 另一方面呢，在敲代码的时候经常会遇到各种各样的问题，在浏览无数帖子之后才解决的问题，可能身边的朋友问你：诶，我这个错误怎么回事啊，你帮我看看； 你看着比较眼熟，好像就是自己刚刚遇到的错误，却忘了是怎么解决的了，于是又要去翻各种技术贴问题贴。随时记录自己发生的问题，解决的问题 无疑是一个好习惯 希望自己在接下来的道路可以做到随时记录，当然想法是好的，对于我这样的懒人来说还是道阻且长啊 加油!","categories":[],"tags":[]}]}