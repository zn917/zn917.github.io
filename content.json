{"meta":{"title":"柊南","subtitle":null,"description":null,"author":"柊南","url":"http://zn917.github.io","root":"/"},"pages":[],"posts":[{"title":"MySQL基于InnoDB的乐观锁、悲观锁理解","slug":"MySQL基于InnoDB的乐观锁、悲观锁理解","date":"2019-07-29T07:02:55.000Z","updated":"2019-07-29T09:56:59.837Z","comments":true,"path":"2019/07/29/MySQL基于InnoDB的乐观锁、悲观锁理解/","link":"","permalink":"http://zn917.github.io/2019/07/29/MySQL基于InnoDB的乐观锁、悲观锁理解/","excerpt":"","text":"MySQL基于InnoDB的乐观锁、悲观锁理解查看存储引擎1show engines; 乐观锁每次获取数据的时候，都不担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断数据是否被别人修改了，如果数据被其他线程修改不进行数据更新，没有被其他线程修改则进行数据更新，由于数据没有进行加锁，此期间数据可以被其他线程进行读写操作 使用场景比较适合读取操作频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量 使用方法使用数据版本（Version）记录机制实现，就是给数据增加一个版本标识，一般通过数据库表增加一个“version”字段来实现，读取数据时，将version字段的值一同读出，数据每更新一次，version值+1，提交更新时，判断数据库对应记录的当前版本信息与第一次取出来的version进行对比，版本号相等就更新，否则认为是过期数据 123update TABLEset value=2,version=version+1where id=#&#123;id&#125; and version=#&#123;version&#125;; 悲观锁每次获取数据的时候，都担心数据被修改，所以每次获取数据的时候都会上个锁锁住，保证自己用的时候别人用不了，用完了就会解锁（因为加了锁，其他要读写数据的线程都要等待） 使用场景适合写入频繁的场景","categories":[],"tags":[]},{"title":"面试问题汇总1","slug":"面试问题","date":"2019-07-29T07:02:55.000Z","updated":"2019-08-20T15:04:31.005Z","comments":true,"path":"2019/07/29/面试问题/","link":"","permalink":"http://zn917.github.io/2019/07/29/面试问题/","excerpt":"","text":"面试问题详解及个人理解Java部分为什么要同时覆盖hashcode和equals回答这个问题首先要知道equals和hashcode是什么, 我们在用JAVA创建自己的类的时候，一种比较常见的覆盖就是覆盖Object中的equals()方法和hashCode()方法。如果不这样做的话，就很可能违反Object.hashCode()的通用约定，从而在利用自己建的类构建需要Hash化的集合的正常工作。其中有一条约定很重要： 如果两个对象利用equals方法比较是相等的，那么这两个对象必须能返回同样的hashCode。 延申：“==”和equals的区别参考：https://blog.csdn.net/lcsy000/article/details/82782864 ==是直接比较的两个对象的堆内存地址，如果相等，则说明这两个引用实际是指向同一个对象地址的。但是我们又常常碰到这样一个问题 Interface和抽象类的区别单例模式详解冒泡排序原理：每次比较两个相邻的元素，将较大的元素交换至右端。 思路：每次冒泡排序操作都会将相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足，就交换这两个相邻元素的次序，一次冒泡至少让一个元素移动到它应该排列的位置，重复N次，就完成了冒泡排序。 代码实例： 12345678910111213141516171819 /** - @program: JavaSpecialityDeep - @author: Mr.Zerah - @create: 2018-10-25 22:52 - @description: 冒泡排序 - 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。 - 如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n 次， - 就完成了 n 个数据的排序工作。 **/ public class BubbleSort &#123; public void bubbleSort(Integer[] arr, int n) &#123; if (n &lt;= 1) return; //如果只有一个元素就不用排序了 for (int i = 0; i &lt; n; ++i) { // 提前退出冒泡循环的标志位,即一次比较中没有交换任何元素，这个数组就已经是有序的了 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) { //此处你可能会疑问的j&lt;n-i-1，因为冒泡是把每轮循环中较大的数飘到后面， // 数组下标又是从0开始的，i下标后面已经排序的个数就得多减1，总结就是i增多少，j的循环位置减多少 if (arr[j] &gt; arr[j + 1]) { //即这两个相邻的数是逆序的，交换 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; } } if (!flag) break;//没有数据交换，数组已经有序，退出排序} 1234567891011 &#125; public static void main(String[] args) &#123; Integer arr[] = &#123;2, 4, 7, 6, 8, 5, 9&#125;; SortUtil.show(arr); BubbleSort bubbleSort = new BubbleSort(); bubbleSort.bubbleSort(arr, arr.length); SortUtil.show(arr);&#125;&#125; ———————————————— 版权声明：本文为CSDN博主「ZerahMu」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/NathanniuBee/article/details/83413879 Mysql&amp;Oracle数据库部分主键索引和唯一索引的区别 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。 唯一性索引列允许空值，而主键列不允许为空值。 主键列在创建时，已经默认为空值 + 唯一索引了。 主键可以被其他表引用为外键，而唯一索引不能。 一个表最多只能创建一个主键，但可以创建多个唯一索引。 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。 Mysql和Oracle分页的应用MySQL有Limt 关键字作用是查出从第几到第几的数据 Oracle使用到的是rowunm 这是一个标识。给每列前面加上序号（从1开始）。 左连接和右连接的区别左连接只影响右表，右链接只影响左表。 左连接 （left join） 1select * from table1 left join tbale2 on table1.id=table2.id 这条sql语句返回结果 table1表中的数据全部返回 table2表中的数据只返回满足where条件的 右链接 （right join） 1select * from table1 right join table2 on table1.id=table2.id 这条sql语句返回结果 table2表中的数据全部返回 table1表中的数据只返回满足where条件的 ​ （inner join） 1select * from table1 inner join table2 on table1.id = table2.id 这条sql语句返回结果 显示满足条件的数据 并不以谁为主表","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇","date":"2019-07-22T05:08:55.000Z","updated":"2019-07-29T07:07:25.038Z","comments":true,"path":"2019/07/22/我的第一篇/","link":"","permalink":"http://zn917.github.io/2019/07/22/我的第一篇/","excerpt":"","text":"我的第一篇博客其实很早之前就有做一个个人博客的念头了，一方面对于求职来说，无论是校招还是社招，拥有属于自己的个人博客无疑是个加分项 另一方面呢，在敲代码的时候经常会遇到各种各样的问题，在浏览无数帖子之后才解决的问题，可能身边的朋友问你：诶，我这个错误怎么回事啊，你帮我看看； 你看着比较眼熟，好像就是自己刚刚遇到的错误，却忘了是怎么解决的了，于是又要去翻各种技术贴问题贴。随时记录自己发生的问题，解决的问题 无疑是一个好习惯 希望自己在接下来的道路可以做到随时记录，当然想法是好的，对于我这样的懒人来说还是道阻且长啊 加油!","categories":[],"tags":[]}]}